(*
  BulbTracer2 for MB3D
  Copyright (C) 2016-2019 Andreas Maschke

  This is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation; either version 2.1 of the
  License, or (at your option) any later version.

  This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without
  even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  Lesser General Public License for more details.
  You should have received a copy of the GNU Lesser General Public License along with this software;
  if not, write to the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  02110-1301 USA, or see the FSF site: http://www.fsf.org.
*)
unit MeshWriter;

interface

uses
  SysUtils, Classes, Contnrs, VectorMath, SyncObjs, Generics.Collections,
  VertexList;

type
  TAbstractFileWriter = class
    class procedure CreateDrawer(const Filename: String);
  end;

  TObjFileWriter = class( TAbstractFileWriter )
  public
    class procedure SaveToFile(const Filename: String; const Faces: TFacesList);
  end;

  TRawMeshFileWriter = class( TAbstractFileWriter )
  public
    class procedure SaveToFile(const Filename: String; const Faces: TFacesList);
  end;

implementation

uses
  Windows, Math, DateUtils, MeshIOUtil, ShellApi, BulbTracer2;

{ --------------------------- TAbstractFileWriter ---------------------------- }
class procedure TAbstractFileWriter.CreateDrawer(const Filename: String);
var
  Folder: String;
begin
  Folder := ExtractFilePath(Filename);
  if (Folder <> '') and (not DirectoryExists(Folder)) then
    CreateDir(Folder);
  if not DirectoryExists(Folder) then
    raise Exception.Create('Can not access Folder <'+Folder+'>');
end;

{ ----------------------------- TObjFileWriter ------------------------------- }
class procedure TObjFileWriter.SaveToFile(const Filename: String; const Faces: TFacesList);
var
  FOut : TextFile;
  TmpBuf: Array[word] of Byte;
  Normals: TPS3VectorList;
  LastDecimalSeparator: Char;
  FormatSettings: TFormatSettings;
  WithColors: Boolean;

  procedure WriteHeader;
  begin
    WriteLn(FOut, '####');
    WriteLn(FOut, '#');
    WriteLn(FOut, '# OBJ File Generated by Mandelbulb3D');
    WriteLn(FOut, '#');
    WriteLn(FOut, '####');
    WriteLn(FOut, '#');
    if Normals <> nil then
      WriteLn(FOut, '# Vertices (with normals): '+IntToStr(Faces.Vertices.Count))
    else
      WriteLn(FOut, '# Vertices: '+IntToStr(Faces.Vertices.Count));
    WriteLn(FOut, '# Faces: '+IntToStr(Faces.Count));
    WriteLn(FOut, '#');
    WriteLn(FOut, '####');
  end;

  procedure WriteFooter;
  begin
    WriteLn(FOut, '# End of File');
  end;

  procedure WriteVertices;
  var
    I: Integer;
    Vertex, N: TPS3Vector;
    ColorIdx1, MinColorIdx1, MaxColorIdx1, DeltaColorIdx1, MappedColorIdx1: double;
    ColorIdx2, MinColorIdx2, MaxColorIdx2, DeltaColorIdx2, MappedColorIdx2: double;
  begin
    for I := 0 to Faces.Vertices.Count - 1  do begin
      Vertex := Faces.Vertices.GetVertex(I);
      WriteLn(FOut, 'v '+FloatToStr(Vertex^.X, FormatSettings)+' '+FloatToStr(Vertex^.Y, FormatSettings)+' '+FloatToStr(Vertex^.Z, FormatSettings));
    end;
    if WithColors  then begin
      MinColorIdx1 := 1.0;
      MaxColorIdx1 := 0.0;
      MinColorIdx2 := 1.0;
      MaxColorIdx2 := 0.0;
      for I := 0 to Faces.Vertices.Count - 1  do begin
        TMCCubes.DecodeColorIdx( Faces.VertexColors[I], ColorIdx1, ColorIdx2 );
        if ColorIdx1 < MinColorIdx1 then
          MinColorIdx1 := ColorIdx1;
        if ColorIdx1 > MaxColorIdx1 then
          MaxColorIdx1 := ColorIdx1;
        if ColorIdx2 < MinColorIdx2 then
          MinColorIdx2 := ColorIdx2;
        if ColorIdx2 > MaxColorIdx2 then
          MaxColorIdx2 := ColorIdx2;
      end;
      DeltaColorIdx1 := MaxColorIdx1 - MinColorIdx1;
      if DeltaColorIdx1 < 0.0001 then
        DeltaColorIdx1 := 0.0001;
      DeltaColorIdx2 := MaxColorIdx2 - MinColorIdx2;
      if DeltaColorIdx2 < 0.0001 then
        DeltaColorIdx2 := 0.0001;
      for I := 0 to Faces.Vertices.Count - 1  do begin
        TMCCubes.DecodeColorIdx( Faces.VertexColors[I], ColorIdx1, ColorIdx2 );
        MappedColorIdx1 := (ColorIdx1 - MinColorIdx1) / DeltaColorIdx1;
        MappedColorIdx2 := (ColorIdx2 - MinColorIdx2) / DeltaColorIdx2;
        WriteLn(FOut, 'vt '+FloatToStr(MappedColorIdx1, FormatSettings)+' '+FloatToStr(MappedColorIdx2, FormatSettings));
      end;
    end;

    if Normals<> nil then begin
      for I := 0 to Faces.Vertices.Count - 1  do begin
        N := Normals.GetVertex(I);
        WriteLn(FOut, 'vn '+FloatToStr(N^.X, FormatSettings)+' '+FloatToStr(N^.Y, FormatSettings)+' '+FloatToStr(N^.Z, FormatSettings));
      end;
      WriteLn(FOut, '# '+IntToStr(Faces.Vertices.Count)+' vertices, '+IntToStr(Faces.Vertices.Count)+' vertices normals')
    end
    else begin
      WriteLn(FOut, '# '+IntToStr(Faces.Vertices.Count)+' vertices');
    end;
  end;

  procedure WriteFaces;
  var
    I, V1, V2, V3: Integer;
    Face: TPFace;
  begin
    for I := 0 to Faces.Count - 1 do begin
      Face := Faces.GetFace(I);
      V1 := Face^.Vertex1 + 1;
      V2 := Face^.Vertex2 + 1;
      V3 := Face^.Vertex3 + 1;
      if Normals<>nil then begin
        if WithColors then
          WriteLn(FOut, 'f '+IntToStr(V1)+'/'+IntToStr(V1)+'/'+IntToStr(V1)+' '+IntToStr(V2)+'/'+IntToStr(V2)+'/'+IntToStr(V2)+' '+IntToStr(V3)+'/'+IntToStr(V3)+'/'+IntToStr(V3))
        else
          WriteLn(FOut, 'f '+IntToStr(V1)+'//'+IntToStr(V1)+' '+IntToStr(V2)+'//'+IntToStr(V2)+' '+IntToStr(V3)+'//'+IntToStr(V3))
      end
      else
        if WithColors then
          WriteLn(FOut, 'f '+IntToStr(V1)+'/'+IntToStr(V1)+'/ '+IntToStr(V2)+'/'+IntToStr(V2)+'/ '+IntToStr(V3)+'/'+IntToStr(V3)+'/')
        else
          WriteLn(FOut, 'f '+IntToStr(V1)+' '+IntToStr(V2)+' '+IntToStr(V3));
    end;
    WriteLn(FOut, '# '+IntToStr(Faces.Count)+' faces');
  end;

begin
  CreateDrawer( Filename );

  WithColors := (Faces.VertexColors<>nil) and (Faces.VertexColors.Count = Faces.Vertices.Count);

  GetLocaleFormatSettings(GetUserDefaultLCID, FormatSettings);
  LastDecimalSeparator := FormatSettings.DecimalSeparator;
  try
    FormatSettings.DecimalSeparator := '.';
    {$I-}
    AssignFile(FOut, Filename);
    try
      ReWrite(FOut);
      SetTextBuf(FOut,TmpBuf);

      Normals := nil;
      try
        // Try to calculate normals
        try
          Normals := Faces.CalculateVertexNormals;
        except
          on E: Exception do begin
            OutputDebugString(PChar('Error creating normals: '+E.Message));
          end;
        end;
        // The file is written if normal calculation failed (due the lack of memory)
        WriteHeader;
        WriteVertices;
        WriteFaces;
        WriteFooter;
      finally
        if Normals <> nil then
          Normals.Free;
      end;
      if IOResult<>0 then
        raise Exception.Create('Error writing file');
    finally
      CloseFile(FOut);
    end;
    {$I+}
  finally
    FormatSettings.DecimalSeparator := LastDecimalSeparator;
  end;
end;

{ ---------------------------- TRawMeshFileWriter ---------------------------- }
class procedure TRawMeshFileWriter.SaveToFile(const Filename: String; const Faces: TFacesList);
begin
  // TODO
end;


end.
